---
layout: page
status: publish
published: true
title: 'Tutorial 8 : Basic shading'
author:
  display_name: Calvin1602
  login: Calvin1602
  email: arnaud1602@gmail.com
  url: ''
author_login: Calvin1602
author_email: arnaud1602@gmail.com
wordpress_id: 198
wordpress_url: http://www.opengl-tutorial.org/?page_id=198
date: '2011-05-08 19:12:46 +0200'
date_gmt: '2011-05-08 19:12:46 +0200'
categories: []
tags: []
---
<p>In this 8th tutorial, we will learn how to do some basic shading. This includes :</p>
<ul>
<li>Beeing more bright when closer to a light source<&#47;li>
<li>Having highlights when looking in the reflection of a light (specular lighting)<&#47;li>
<li>Beeing darker when light is not directly towards the model (diffuse lighting)<&#47;li>
<li>Cheating a lot (ambient lighting)<&#47;li><br />
<&#47;ul><br />
This does NOT include :</p>
<ul>
<li>Shadows. This is a broad topic that deserves its own tutorial(s)<&#47;li>
<li>Mirror-like reflections (this includes water)<&#47;li>
<li>Any sophisticated light-matter interaction like subsurface scattering (like wax)<&#47;li>
<li>Anisotrophic materials (like brushed metal)<&#47;li>
<li>Physically based shading, which tries to mimic the reality closely<&#47;li>
<li>Ambient Occlusion (it's darker in a cave)<&#47;li>
<li>Color Bleeding (a red carpet will make a white ceiling a litte bit red)<&#47;li>
<li>Transparency<&#47;li>
<li>Any kind of Global Illumination whatsoever (it's the name that regroups all previous ones)<&#47;li><br />
<&#47;ul><br />
In a word : Basic.</p>
<h1>Normals<&#47;h1><br />
During the last few tutorials you've been dealing with normal without really knowing what they were.</p>
<h2>Triangle normals<&#47;h2><br />
The normal of a plane is a vector of length 1 that is perpendicular to this plane.</p>
<p>The normal of a triangle is a vector of length 1 that is perpendicular to this triangle. It is easily computed by taking the cross product of two of its edges (the cross product of a and b produces a vector that is perpendicular to both a and b, remember ?), and normalized : its length is brought back to 1. In pseudo-code :</p>
<pre>triangle ( v1, v2, v3 )<br />
edge1 = v2-v1<br />
edge2 = v3-v1<br />
triangle.normal = cross(edge1, edge2).normalize()<&#47;pre><br />
Don't mix up normal and normalize(). Normalize() divides a vector (any vector, not necessarily a normal) by its length so that its new length is 1. normal is just the name for some vectors that happen to represent, well, a normal.</p>
<h2>Vertex normals<&#47;h2><br />
By extension, we call the normal of a vertex the combination of the normals of the surroundings triangles. This is handy because in vertex shaders, we deal with vertices, not triangles, so it's better to have information on the vertex. And any way, we can't have information on triangles in OpenGL. In pseudo-code :</p>
<pre>vertex v1, v2, v3, ....<br />
triangle tr1, tr2, tr3 &#47;&#47; all share vertex v1<br />
v1.normal = normalize( tr1.normal + tr2.normal + tr3.normal )<&#47;pre></p>
<h2>Using vertex normals in OpenGL<&#47;h2><br />
To use normals in OpenGL, it's very easy. A normal is an attribute of a vertex, just like its position, its color, its UV coordinates... so just do the usual stuff. Our loadOBJ function from Tutorial 7 already reads them from the OBJ file.</p>
<pre class="brush: cpp">GLuint normalbuffer;<br />
 glGenBuffers(1, &amp;normalbuffer);<br />
 glBindBuffer(GL_ARRAY_BUFFER, normalbuffer);<br />
 glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);<&#47;pre><br />
and</p>
<pre class="brush: cpp"> &#47;&#47; 3rd attribute buffer : normals<br />
 glEnableVertexAttribArray(2);<br />
 glBindBuffer(GL_ARRAY_BUFFER, normalbuffer);<br />
 glVertexAttribPointer(<br />
     2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; attribute<br />
     3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; size<br />
     GL_FLOAT,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; type<br />
     GL_FALSE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; normalized?<br />
     0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; stride<br />
     (void*)0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; array buffer offset<br />
 );<&#47;pre><br />
and this is enough to get us started.</p>
<h1>The Diffuse part<&#47;h1></p>
<h2>The importance of the surface normal<&#47;h2><br />
When light hits an object, an important fraction of it is reflected in all directions. This is the "diffuse component". (We'll see what happens with the other fraction soon)</p>
<p><a href="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;diffuseWhite1.png"><img class="alignnone size-full wp-image-225" title="diffuseWhite" src="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;diffuseWhite1.png" alt="" width="500" height="303" &#47;><&#47;a></p>
<p>When a certain flux of light arrives at the surface, this surface is illuminated differently according to the angle at which the light arrives.</p>
<p>If the light is perpendicular to the surface, it is concentrated on a small surface. If it arrives at a gazing angle, the same quantity of light spreads on a greater surface :</p>
<p><a href="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;diffuseAngle.png"><img class="alignnone size-full wp-image-227" title="diffuseAngle" src="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;diffuseAngle.png" alt="" width="600" height="500" &#47;><&#47;a></p>
<p>This means that each point of the surface will look darker with gazing light (but remember, more points will be illuminated, to the total quantity of light will remain the same)</p>
<p>This means that when we compute the colour of a pixel, the angle between the incoming light and the surface normal matters.We thus have :</p>
<pre class="brush: fs">&#47;&#47; Cosine of the angle between the normal and the light direction,<br />
&#47;&#47; clamped above 0<br />
&#47;&#47;&nbsp; - light is at the vertical of the triangle -> 1<br />
&#47;&#47;&nbsp; - light is perpendicular to the triangle -> 0<br />
float cosTheta = dot( n,l );</p>
<p>color = LightColor * cosTheta;<&#47;pre><br />
In this code, n is the surface normal and l is the unit vector that goes from the surface to the light (and not the contrary, even if it's non inuitive. It makes the math easier).</p>
<h2>Beware of the sign<&#47;h2><br />
Something is missing in the formula of our cosTheta. If the light is behind the triangle, n and l will be opposed, so n.l will be negative. This would mean that colour = someNegativeNumber, which doesn't mean much. So we have to clamp cosTheta to 0 :</p>
<pre class="brush: fs">&#47;&#47; Cosine of the angle between the normal and the light direction,<br />
&#47;&#47; clamped above 0<br />
&#47;&#47;&nbsp; - light is at the vertical of the triangle -> 1<br />
&#47;&#47;&nbsp; - light is perpendicular to the triangle -> 0<br />
&#47;&#47;&nbsp; - light is behind the triangle -> 0<br />
float cosTheta = clamp( dot( n,l ), 0,1 );</p>
<p>color = LightColor * cosTheta;<&#47;pre></p>
<h2>Material Color<&#47;h2><br />
Of course, the output colour also depends on the colour of the material. In this image, the white light is made out of green, red and blue light. When colliding with the red material, green and blue light is absorbed, and only the red remains.</p>
<p><a href="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;diffuseRed.png"><img class="alignnone size-full wp-image-226" title="diffuseRed" src="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;diffuseRed.png" alt="" width="500" height="303" &#47;><&#47;a></p>
<p>We can model this by a simple multiplication :</p>
<pre class="brush: fs">color = MaterialDiffuseColor * LightColor * cosTheta;<&#47;pre></p>
<h2>Modeling the light<&#47;h2><br />
We will first assume that we have a punctual light that emits in all directions in space, like a candle.</p>
<p>With such a light, the luminous flux that our surface will receive will depend on its distance to the light source: the further away, the less light. In fact, the amount of light will diminish with the square of the distance :</p>
<pre class="brush: fs">color = MaterialDiffuseColor * LightColor * cosTheta &#47; (distance*distance);<&#47;pre><br />
Lastly, we need another parameter to control the power of the light. This could be encoded into LightColor (and we will in a later tutorial), but for now let's just have a color (e.g. white) and a power (e.g. 60 Watts).</p>
<pre class="brush: fs">color = MaterialDiffuseColor * LightColor * LightPower * cosTheta &#47; (distance*distance);<&#47;pre></p>
<h2>Putting it all together<&#47;h2><br />
For this code to work, we need a handful of parameters (the various colours and powers) and some more code.</p>
<p>MaterialDiffuseColor is simply fetched from the texture.</p>
<p>LightColor and LightPower are set in the shader through GLSL uniforms.</p>
<p>cosTheta depends on n and l. We can express them in any space provided it's the same for both. We choose the camera space because it's easy to compute the light's position in this space :</p>
<pre class="brush: fs">&#47;&#47; Normal of the computed fragment, in camera space<br />
 vec3 n = normalize( Normal_cameraspace );<br />
 &#47;&#47; Direction of the light (from the fragment to the light)<br />
 vec3 l = normalize( LightDirection_cameraspace );<&#47;pre><br />
with Normal_cameraspace and LightDirection_cameraspace computed in the Vertex shader and passed to the fragment shader :</p>
<pre class="brush: vs">&#47;&#47; Output position of the vertex, in clip space : MVP * position<br />
gl_Position =&nbsp; MVP * vec4(vertexPosition_modelspace,1);</p>
<p>&#47;&#47; Position of the vertex, in worldspace : M * position<br />
Position_worldspace = (M * vec4(vertexPosition_modelspace,1)).xyz;</p>
<p>&#47;&#47; Vector that goes from the vertex to the camera, in camera space.<br />
&#47;&#47; In camera space, the camera is at the origin (0,0,0).<br />
vec3 vertexPosition_cameraspace = ( V * M * vec4(vertexPosition_modelspace,1)).xyz;<br />
EyeDirection_cameraspace = vec3(0,0,0) - vertexPosition_cameraspace;</p>
<p>&#47;&#47; Vector that goes from the vertex to the light, in camera space. M is ommited because it's identity.<br />
vec3 LightPosition_cameraspace = ( V * vec4(LightPosition_worldspace,1)).xyz;<br />
LightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;</p>
<p>&#47;&#47; Normal of the the vertex, in camera space<br />
Normal_cameraspace = ( V * M * vec4(vertexNormal_modelspace,0)).xyz; &#47;&#47; Only correct if ModelMatrix does not scale the model ! Use its inverse transpose if not.<&#47;pre><br />
This code can seem impressive but it's nothing we didn't learn in Tutorial 3 : Matrices. I paid attention to write the name of the space in each vector's name, so that keeping track of what is happening is much easier. <strong>You should do that, too.<&#47;strong></p>
<p>M and V are the Model and View matrices, which are passed to the shader in the exact same way as MVP.</p>
<h2>Time for work<&#47;h2><br />
You've got everything you need to code a diffuse lighting. Go ahead, and learn the hard way :)</p>
<h2>Result<&#47;h2><br />
With only the Diffuse component, we have the following result (sorry for the lame texture again) :</p>
<p><a href="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;diffuse_only.png"><img class="alignnone size-large wp-image-228" title="diffuse_only" src="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;diffuse_only-1024x793.png" alt="" width="640" height="495" &#47;><&#47;a></p>
<p>It's better than before, but there is still much missing. In particular, the back of Suzanne is completely black since we used clamp().</p>
<h1>The Ambient component<&#47;h1><br />
The Ambient component is the biggest cheat ever.</p>
<p>We expect the back of Suzanne to be receive more light because in real life, the lamp would light the wall behind it, which would in turn (slightly less) light the back of the object.</p>
<p>This is awfully expensive to compute.</p>
<p>So the usual hack is to simply fake some light. In fact, is simply makes the 3D model <em>emit <&#47;em>light so that it doesn't appear completely black.</p>
<p>This can be done this way :</p>
<pre class="brush: fs">vec3 MaterialAmbientColor = vec3(0.1,0.1,0.1) * MaterialDiffuseColor;<&#47;pre></p>
<pre class="brush: fs">color =<br />
 &#47;&#47; Ambient : simulates indirect lighting<br />
 MaterialAmbientColor +<br />
 &#47;&#47; Diffuse : "color" of the object<br />
 MaterialDiffuseColor * LightColor * LightPower * cosTheta &#47; (distance*distance) ;<&#47;pre><br />
Let's see what it gives</p>
<h2>Results<&#47;h2><br />
Ok so that's a little bit better. You can adjust the (0.1, 0.1, 0.1) if you want better results.</p>
<p><a href="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;diffuse_ambiant.png"><img class="alignnone size-large wp-image-229" title="diffuse_ambiant" src="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;diffuse_ambiant-1024x793.png" alt="" width="640" height="495" &#47;><&#47;a></p>
<h1>The Specular component<&#47;h1><br />
The other part of light that is reflected is reflected mostly in the direction that is the reflection of the light on the surface. This is the specular component.</p>
<p><a href="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;specular.png"><img class="alignnone size-full wp-image-232" title="specular" src="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;specular.png" alt="" width="500" height="251" &#47;><&#47;a></p>
<p>As you can see in the image, it forms a kind of lobe. In extreme cases, the diffuse component can be null, the lobe can be very very very narrow (all the light is reflected in a single direction) and you get a mirror.</p>
<p>(<em>we can indeed tweak the parameters to get a mirror, but in our case, the only thing we take into account in this mirror is the lamp. So this would make for a weird mirror)<&#47;em></p>
<pre class="brush: fs">&#47;&#47; Eye vector (towards the camera)<br />
vec3 E = normalize(EyeDirection_cameraspace);<br />
&#47;&#47; Direction in which the triangle reflects the light<br />
vec3 R = reflect(-l,n);<br />
&#47;&#47; Cosine of the angle between the Eye vector and the Reflect vector,<br />
&#47;&#47; clamped to 0<br />
&#47;&#47;&nbsp; - Looking into the reflection -> 1<br />
&#47;&#47;&nbsp; - Looking elsewhere -> < 1<br />
float cosAlpha = clamp( dot( E,R ), 0,1 );</p>
<p>color =<br />
    &#47;&#47; Ambient : simulates indirect lighting<br />
    MaterialAmbientColor +<br />
    &#47;&#47; Diffuse : "color" of the object<br />
    MaterialDiffuseColor * LightColor * LightPower * cosTheta &#47; (distance*distance) ;<br />
    &#47;&#47; Specular : reflective highlight, like a mirror<br />
    MaterialSpecularColor * LightColor * LightPower * pow(cosAlpha,5) &#47; (distance*distance);<&#47;pre><br />
R is the direction in which the light reflects. E is the inverse direction of the eye (just like we did for "l"); If the angle between these two is little, it means we are looking straight into the reflection.</p>
<p>pow(cosAlpha,5) is used to control the width of the specular lobe. Increase 5 to get a thinner lobe.</p>
<h2>Final result<&#47;h2><br />
<a href="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;diffuse_ambiant_specular.png"><img class="alignnone size-large wp-image-233" title="diffuse_ambiant_specular" src="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;diffuse_ambiant_specular-1024x793.png" alt="" width="640" height="495" &#47;><&#47;a></p>
<p>Notice the specular highlights on the nose and on the eyebrows.</p>
<p>This shading model has been used for years due to its simplicity. It has a number of problems, so it is replaced by physically-based models like the microfacet BRDF, but we will see this later.</p>
<p>In the next tutorial, we'll learn how to improve the performance of your VBO. This will be the first Intermediate tutorial !</p>
