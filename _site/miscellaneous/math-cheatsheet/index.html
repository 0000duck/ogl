<h1>Trigonometry</h1>
<p>&lt;/p&gt;</p>
<h2>Pi</h2>
<p><br />
const float pi = 3.14159265f; // but an infinity of digits in reality&lt;/p&gt;</p>
<h2>Cosinus &amp; Sinus</h2>
<p><br />
<img class="alignnone" title="Sine_cosine_one_period" src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/71/Sine_cosine_one_period.svg/600px-Sine_cosine_one_period.svg.png" alt="" width="600" height="240" />&lt;/p&gt;</p>
<address>(From http://commons.wikimedia.org/wiki/User:Geek3 , under GNU Free Documentation License )</address>
<p>&lt;/p&gt;</p>
<h2>Unit circle</h2>
<p><br />
<a href="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/UnitCircle.png"><img class="alignnone size-full wp-image-213 whiteborder" title="UnitCircle" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/UnitCircle.png" alt="" width="300" height="300" /></a>&lt;/p&gt;</p>
<address>( Modified from http://en.wikipedia.org/wiki/User:Gustavb under Crative Commons 3.0 )</address>
<p>t is an angle in radians.&lt;/p&gt;</p>
<p>0 radians = 0 degrees</p>
<p>180 degrees = Pi radians</p>
<p>360 degrees ( full circle ) = 2*Pi radians</p>
<p>90 degrees = Pi/2 radians</p>
<h1>Vectors</h1>
<p><br />
ALWAYS know in which coordinates your vector is. See section 3 for details.&lt;/p&gt;</p>
<h2>Homogeneous coordinates</h2>
<p><br />
A 3D vector is (x,y,z), but a homogeneous 3D vector is (x,y,z,w).&lt;/p&gt;</p>
<ul>
<li>w=0 : it's a direction</li>
<li>w=1 : it's a position</li>
<li>else : it may still be correct, but you'd better know what you're doing.</li><br />
</ul>
<p><br />
You can only multiply a 4x4 matrix with a homogeneous vector.&lt;/p&gt;</p>
<h2>Length</h2>
<p><br />
Just like cartesian distance : sqrt( x² + y² + z² ). w doesn’t count.&lt;/p&gt;</p>
<h2>Cross product</h2>
<p><br />
<a href="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/Right_hand_rule_cross_product.png"><img class="alignnone size-full wp-image-211" title="Right_hand_rule_cross_product" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/Right_hand_rule_cross_product.png" alt="" width="400" height="353" /></a>&lt;/p&gt;</p>
<address>( Modified from http://en.wikipedia.org/wiki/User:Acdx , former image under Creative Commons 3.0 )</address>
<p>The X is the notation for the cross product. length( a x b ) == length(a) * length(b) * sin(θ), so you may want to normalize() the result.&lt;/p&gt;</p>
<h2>Dot product</h2>
<p>&lt;/p&gt;</p>
<h2><a href="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/DotProduct.png"><img class="alignnone size-full wp-image-212 whiteborder" title="DotProduct" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/05/DotProduct.png" alt="" width="500" height="133" /></a></h2>
<p>&lt;/p&gt;</p>
<address>( from http://en.wikipedia.org/wiki/File:Dot_Product.svg )</address>
<p>A.B = length(A)<em>cos(Theta) , but most likely computed as A.x</em>B.x +A.y<em>B.y +A.z</em>B.z&lt;/p&gt;</p>
<h2>Addition and substraction</h2>
<p><br />
compontent-wise :&lt;/p&gt;</p>
<pre>res.x = A.x + B.x<br />
res.y = A.y + B.y<br />
...</pre>
<p><br />
 &lt;/p&gt;</p>
<h2>Multiplication</h2>
<p><br />
compontent-wise :&lt;/p&gt;</p>
<pre>res.x = A.x * B.x<br />
res.y = A.y * B.y<br />
...</pre>
<p>&lt;/p&gt;</p>
<h2>Normalization</h2>
<p><br />
Divide the vector by its length :&lt;/p&gt;</p>
<pre>normalizedVector = vec * ( 1.0f / vec.length() )</pre>
<p>&lt;/p&gt;</p>
<h1>Matrices</h1>
<p>&lt;/p&gt;</p>
<h2>Matrix-Matrix multiplication</h2>
<p><br />
example for a translation matrix :&lt;/p&gt;</p>
<p><a href="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/translationExamplePosition1.png"><img class="alignnone size-full wp-image-798" title="translationExamplePosition" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/translationExamplePosition1.png" alt="" width="639" height="82" /></a></p>
<p>&nbsp;</p>
<h2>Matrix-Vector multiplication</h2>
<p><br />
<a href="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/MatrixXVect.gif"><img class="alignnone size-full wp-image-64 whiteborder" title="MatrixXVect" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/MatrixXVect.gif" alt="" width="367" height="88" /></a>&lt;/p&gt;</p>
<h1>Usual Transformations</h1>
<p><br />
<a href="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/MVP.png"><img class="alignnone size-full wp-image-66 whiteborder" title="MVP" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/MVP.png" alt="" width="300" height="382" /></a>&lt;/p&gt;</p>
<p>... but in your shaders, you can also represent your vectors in tangent space. And in image-space when you do post-effects.</p>
<div id="_mcePaste" class="mcePaste" style="position: absolute; left: -10000px; top: 1254px; width: 1px; height: 1px; overflow: hidden;">res.x = A.x + B.x</div>
<p>&lt;/p&gt;</p>
