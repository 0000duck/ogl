---
layout: page
status: publish
published: true
title: 'Урок 4: Цветной куб'
author:
  display_name: Calvin1602
  login: Calvin1602
  email: arnaud1602@gmail.com
  url: ''
author_login: Calvin1602
author_email: arnaud1602@gmail.com
wordpress_id: 1257
wordpress_url: http://www.opengl-tutorial.org/?page_id=1257
date: '2014-04-27 13:43:42 +0100'
date_gmt: '2014-04-27 13:43:42 +0100'
categories: []
tags: []
comments: []
language: ru
---
<p>Добро пожаловать на наш четвертый урок! Сегодня мы займемся:</p>
<ul>
<li>Рисованием куба, вместо скучного треугольника<&#47;li>
<li>Добавлением цвета<&#47;li>
<li>Изучением Буфера Глубины (Z-Buffer)<&#47;li><br />
<&#47;ul></p>
<h1>Рисование куба<&#47;h1><br />
Куб имеет 6 прямоугольных граней, однако OpenGL знает только о треугольниках, поэтому все, что мы делаем - это выводим 12 треугольников (по 2 на каждую грань). Задаем вершины точно также, как мы делали это для треугольника:</p>
<pre>&#47;&#47; Наши вершины. Три вещественных числа дают нам вершину. Три вершины дают нам треугольник.<br />
&#47;&#47; Куб имеет 6 граней или 12 треугольников, значит нам необходимо 12 * 3 = 36 вершин для описания куба.<br />
static const GLfloat g_vertex_buffer_data[] = {<br />
    -1.0f,-1.0f,-1.0f, &#47;&#47; Треугольник 1 : начало<br />
    -1.0f,-1.0f, 1.0f,<br />
    -1.0f, 1.0f, 1.0f, &#47;&#47; Треугольник 1 : конец<br />
    1.0f, 1.0f,-1.0f, &#47;&#47; Треугольник 2 : начало<br />
    -1.0f,-1.0f,-1.0f,<br />
    -1.0f, 1.0f,-1.0f, &#47;&#47; Треугольник 2 : конец<br />
    1.0f,-1.0f, 1.0f,<br />
    -1.0f,-1.0f,-1.0f,<br />
    1.0f,-1.0f,-1.0f,<br />
    1.0f, 1.0f,-1.0f,<br />
    1.0f,-1.0f,-1.0f,<br />
    -1.0f,-1.0f,-1.0f,<br />
    -1.0f,-1.0f,-1.0f,<br />
    -1.0f, 1.0f, 1.0f,<br />
    -1.0f, 1.0f,-1.0f,<br />
    1.0f,-1.0f, 1.0f,<br />
    -1.0f,-1.0f, 1.0f,<br />
    -1.0f,-1.0f,-1.0f,<br />
    -1.0f, 1.0f, 1.0f,<br />
    -1.0f,-1.0f, 1.0f,<br />
    1.0f,-1.0f, 1.0f,<br />
    1.0f, 1.0f, 1.0f,<br />
    1.0f,-1.0f,-1.0f,<br />
    1.0f, 1.0f,-1.0f,<br />
    1.0f,-1.0f,-1.0f,<br />
    1.0f, 1.0f, 1.0f,<br />
    1.0f,-1.0f, 1.0f,<br />
    1.0f, 1.0f, 1.0f,<br />
    1.0f, 1.0f,-1.0f,<br />
    -1.0f, 1.0f,-1.0f,<br />
    1.0f, 1.0f, 1.0f,<br />
    -1.0f, 1.0f,-1.0f,<br />
    -1.0f, 1.0f, 1.0f,<br />
    1.0f, 1.0f, 1.0f,<br />
    -1.0f, 1.0f, 1.0f,<br />
    1.0f,-1.0f, 1.0f<br />
};<&#47;pre><br />
OpenGL буфер создается, привязывается, заполняется и конфигурируется стандартными функциями (glGenBuffers, glBindBuffer, glBufferData, glVertexAttribPointer); Смотрите Урок 2, чтобы освежить память. Сама процедура вывода не меняется и все, что меняется - это количество вершин, которые мы будем выводить:</p>
<pre>&#47;&#47; Вывести треугольник<br />
glDrawArrays(GL_TRIANGLES, 0, 12*3); &#47;&#47; 12*3 индексов начинающихся с 0. -> 12 треугольников -> 6 граней.<&#47;pre><br />
Несколько заметок по этому коду:</p>
<ul>
<li>Сейчас наша модель статична, таким образом, чтобы изменить ее, нам понадобится изменить исходных код, перекомпилировать проект и надеяться на лучшее. Мы узнаем как загружать модели во время выполнения программы в Уроке 7.<&#47;li>
<li>Каждая вершина в нашем случае указывается как минимум три раза (например посмотрите на "-1.0f, -1.0f, -1.0f" в коде выше). Это бесполезная растрата памяти и вычислительной мощности. Мы узнаем, как избавиться от дублирующихся вершин в Уроке 9.<&#47;li><br />
<&#47;ul></p>
<h1>Добавление цвета<&#47;h1><br />
Цвет в понимании OpenGL - это тоже самое, что и позиция, т. е. просто данные. В терминологии они называются атрибутами. Мы уже работали с ними, с помощью таких функций, как: glEnableVertexAttribArray() и glVertexAttribPointer(). Теперь мы добавим еще один атрибут и код для этого действия будет очень похож.</p>
<p>Первым делом мы объявляем наши цвета - один RGB триплет на вершину. Этот массив был сгенерирован случайно, поэтому результат будет выглядеть не очень красиво, однако ничто не мешает вам сделать его лучше:</p>
<pre>&#47;&#47; Один цвет для каждой вершины<br />
static const GLfloat g_color_buffer_data[] = {<br />
    0.583f,  0.771f,  0.014f,<br />
    0.609f,  0.115f,  0.436f,<br />
    0.327f,  0.483f,  0.844f,<br />
    0.822f,  0.569f,  0.201f,<br />
    0.435f,  0.602f,  0.223f,<br />
    0.310f,  0.747f,  0.185f,<br />
    0.597f,  0.770f,  0.761f,<br />
    0.559f,  0.436f,  0.730f,<br />
    0.359f,  0.583f,  0.152f,<br />
    0.483f,  0.596f,  0.789f,<br />
    0.559f,  0.861f,  0.639f,<br />
    0.195f,  0.548f,  0.859f,<br />
    0.014f,  0.184f,  0.576f,<br />
    0.771f,  0.328f,  0.970f,<br />
    0.406f,  0.615f,  0.116f,<br />
    0.676f,  0.977f,  0.133f,<br />
    0.971f,  0.572f,  0.833f,<br />
    0.140f,  0.616f,  0.489f,<br />
    0.997f,  0.513f,  0.064f,<br />
    0.945f,  0.719f,  0.592f,<br />
    0.543f,  0.021f,  0.978f,<br />
    0.279f,  0.317f,  0.505f,<br />
    0.167f,  0.620f,  0.077f,<br />
    0.347f,  0.857f,  0.137f,<br />
    0.055f,  0.953f,  0.042f,<br />
    0.714f,  0.505f,  0.345f,<br />
    0.783f,  0.290f,  0.734f,<br />
    0.722f,  0.645f,  0.174f,<br />
    0.302f,  0.455f,  0.848f,<br />
    0.225f,  0.587f,  0.040f,<br />
    0.517f,  0.713f,  0.338f,<br />
    0.053f,  0.959f,  0.120f,<br />
    0.393f,  0.621f,  0.362f,<br />
    0.673f,  0.211f,  0.457f,<br />
    0.820f,  0.883f,  0.371f,<br />
    0.982f,  0.099f,  0.879f<br />
};<&#47;pre><br />
Создание, привязывание и заполнения буфера такое же, как и для предыдущего буфера:</p>
<pre>GLuint colorbuffer;<br />
glGenBuffers(1, &amp;colorbuffer);<br />
glBindBuffer(GL_ARRAY_BUFFER, colorbuffer);<br />
glBufferData(GL_ARRAY_BUFFER, sizeof(g_color_buffer_data), g_color_buffer_data, GL_STATIC_DRAW);<&#47;pre><br />
Конфигурация тоже идентична:</p>
<pre>&#47;&#47; Второй буфер атрибутов - цвета<br />
glEnableVertexAttribArray(1);<br />
glBindBuffer(GL_ARRAY_BUFFER, colorbuffer);<br />
glVertexAttribPointer(<br />
    1,                                &#47;&#47; Атрибут. Здесь необязательно указывать 1, но главное, чтобы это значение совпадало с layout в шейдере..<br />
    3,                                &#47;&#47; Размер<br />
    GL_FLOAT,                         &#47;&#47; Тип<br />
    GL_FALSE,                         &#47;&#47; Нормализован?<br />
    0,                                &#47;&#47; Шаг<br />
    (void*)0                          &#47;&#47; Смещение<br />
);<&#47;pre><br />
Теперь, в вершинном шейдере мы имеем доступ к дополнительному буферу:</p>
<pre>&#47;&#47; Не забывайте, что значение "1" здесь должно быть идентично значению атрибута в glVertexAttribPointer<br />
layout(location = 1) in vec3 vertexColor;<&#47;pre><br />
В нашем случае мы не будем выполнять в вершинном шейдере какой-то дополнительной работы, поэтому просто передадим информацию в Фрагментный шейдер.</p>
<pre>&#47;&#47; Выходные данные. Будут интерполироваться для каждого фрагмента.<br />
out vec3 fragmentColor;</p>
<p>void main(){</p>
<p>    [...]</p>
<p>    &#47;&#47; Цвет каждой вершины будет интерполирован для получения цвета<br />
    &#47;&#47; каждого фрагмента<br />
    fragmentColor = vertexColor;<br />
}<&#47;pre><br />
В Фрагментом шейдере мы опять объявляем fragmentColor:</p>
<pre>&#47;&#47; Интерполированные значения из вершинного шейдера<br />
in vec3 fragmentColor;<&#47;pre><br />
&hellip; и копируем это в финальный выходной цвет:</p>
<pre>&#47;&#47; Выходные данные<br />
out vec3 color;</p>
<p>void main(){<br />
    &#47;&#47; Выходной цвет = цвету, указанному в вершинном шейдере,<br />
    &#47;&#47; интерполированному между 3 близлежащими вершинами.<br />
    color = fragmentColor;<br />
}<&#47;pre><br />
И вот, что мы получили в итоге:</p>
<p><a href="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;04&#47;missing_z_buffer.png"><img title="missing_z_buffer" alt="" src="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;04&#47;missing_z_buffer-300x231.png" width="300" height="231" &#47;><&#47;a></p>
<p>Ух, выглядит как-то уродливо. Давайте посмотрим что происходит, когда мы выводим треугольник, который находится дальше, а потом треугольник, который находится ближе (far - дальний, near - ближний):</p>
<p><a href="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;04&#47;FarNear.png"><img title="FarNear" alt="" src="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;04&#47;FarNear.png" width="189" height="94" &#47;><&#47;a></p>
<p>Это правильно,&nbsp; и теперь посмотрим как это будет в обратном порядке:</p>
<p><a href="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;04&#47;NearFar.png"><img title="NearFar" alt="" src="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;04&#47;NearFar.png" width="189" height="94" &#47;><&#47;a></p>
<p>Выходит, что дальний треугольник перекрывает ближний, вместо того, чтобы быть позади. Это тоже самое, что произошло и с нашим кубом. Некоторые грани, которые должны быть невидимы были отрисованы последними и в итоге закрыли собой видимые. Здесь нам на помощь придет Буфер глубины (Z-Buffer).</p>
<p><em>Заметка 1: Если вы не видите проблемы, то попробуйте сменить позицию камеры в (4, 3, -3)<&#47;em></p>
<p><em>Заметка 2: Если "цвет, как и позиция является атрибутом", то почему мы должны вводить переменную vec3 fragmentColor и работать с цветом через нее? Потому что позиция - это специальный атрибут и без него OpenGL будет просто не знать где отобразить треугольник, поэтому в вершинном шейдере есть встроенная переменная gl_Position.<&#47;em></p>
<h1>Буфер глубины (Z-Buffer)<&#47;h1><br />
Решение проблемы заключается в хранении глубины (т. е. "Z" компоненты) каждого фрагмента в буфере и всякий раз, когда вы хотите вывести фрагмент, вам надо будет проверять, является ли он ближним или дальним.</p>
<p>Вы можете реализовать это сами, но гораздо более простым и элегантным решением будет использовать функционал OpenGL для этих целей:</p>
<pre>&#47;&#47; Включить тест глубины<br />
glEnable(GL_DEPTH_TEST);<br />
&#47;&#47; Фрагмент будет выводиться только в том, случае, если он находится ближе к камере, чем предыдущий<br />
glDepthFunc(GL_LESS);<&#47;pre><br />
Вам также необходимо очищать буфер глубины перед каждым кадром:</p>
<pre>&#47;&#47; Очистка экрана<br />
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<&#47;pre><br />
И этого достаточно, чтобы решить нашу проблему.</p>
<p><a href="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;04&#47;one_color_per_vertex.png"><img title="one_color_per_vertex" alt="" src="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;04&#47;one_color_per_vertex-300x231.png" width="300" height="231" &#47;><&#47;a></p>
<h1>Упражнения<&#47;h1></p>
<ul>
<li>Нарисуйте куб и треугольник в разных позициях. Для решения вам понадобится 2 MVP-матрицы, чтобы выполнить 2 вызова процедуры вывода в главном цикле, однако шейдер вам нужен только 1.<&#47;li>
<li>Попробуйте изменить значения цветов. Например, вы можете заполнять массив цветовых атрибутов случайными значениями во время запуска программы. Можете сделать значение цвета зависимым от позиции вершины. Можете попробовать что-нибудь другое, что придет вам в голову :) Если вы не знаете как заполнить массив во время выполнения программы, то вот так это выглядит в Си:<&#47;li><br />
<&#47;ul></p>
<pre>static GLfloat g_color_buffer_data[12*3*3];<br />
for (int v = 0; v < 12*3 ; v++){<br />
    g_color_buffer_data[3*v+0] = здесь укажите значение красной компоненты цвета;<br />
    g_color_buffer_data[3*v+1] = здесь зеленой;<br />
    g_color_buffer_data[3*v+2] = и наконец значение синей компоненты;<br />
}<&#47;pre></p>
<ul>
<li>После выполнения предыдущих упражнений попробуйте сделать так, чтобы цвета менялись каждый кадр. Здесь вам понадобится вызывать glBufferData в каждом кадре. <strong>Убедитесь, что перед этим не забыли привязать соответствующий буфер (glBindBuffer)!<&#47;strong><&#47;li><br />
<&#47;ul><br />
На этом наш урок закончен. В следующем уроке мы поговорим о текстурах.</p>
