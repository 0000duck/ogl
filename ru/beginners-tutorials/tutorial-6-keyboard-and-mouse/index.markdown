---
layout: page
status: publish
published: true
title: 'Урок 6: Клавиатура и мышь'
author:
  display_name: Calvin1602
  login: Calvin1602
  email: arnaud1602@gmail.com
  url: ''
author_login: Calvin1602
author_email: arnaud1602@gmail.com
wordpress_id: 1259
wordpress_url: http://www.opengl-tutorial.org/?page_id=1259
date: '2014-05-01 13:23:57 +0100'
date_gmt: '2014-05-01 13:23:57 +0100'
categories: []
tags: []
comments: []
language: ru
---
<p>Добро пожаловать на наш шестой урок!</p>
<p>Пришло время узнать, как использовать клавиатуру и мышь, чтобы перемещать камеру также, как и в играх жанра FPS.</p>
<h1>Интерфейс<&#47;h1><br />
Так как код этого урока будет использоваться в дальнейшем, мы поместим его в отдельный файл common&#47;controls.cpp и объявим необходимые функции в common&#47;controls.hpp, таким образом tutorial06.cpp будет их видеть.</p>
<p>Код этого урока будет мало отличаться от предыдущих. Главное отличие состоит в том, что теперь мы будем вычислять MVP матрицу не единожды, а в каждом кадре, поэтому давайте перейдем к коду главного цикла:</p>
<pre>do{</p>
<p>    &#47;&#47; ...</p>
<p>    &#47;&#47; Вычислить MVP-матрицу в зависимости от положения мыши и нажатых клавиш<br />
    computeMatricesFromInputs();<br />
    glm::mat4 ProjectionMatrix = getProjectionMatrix();<br />
    glm::mat4 ViewMatrix = getViewMatrix();<br />
    glm::mat4 ModelMatrix = glm::mat4(1.0);<br />
    glm::mat4 MVP = ProjectionMatrix * ViewMatrix * ModelMatrix;</p>
<p>    &#47;&#47; ...<br />
}<&#47;pre><br />
Этот отрывок кода имеет 3 новых функции:</p>
<ul>
<li>computeMatricesFromInputs() вычисляет Проекционную и Видовую матрицы в зависимости от текущего ввода. Это та функция, где происходит основная работа.<&#47;li>
<li>getProjectionMatrix() просто возвращает вычисленную Проекционную матрицу.<&#47;li>
<li>getViewMatrix() просто возвращает вычисленную Видовую матрицу.<&#47;li><br />
<&#47;ul><br />
Конечно же, указанный способ - один из немногих которым вы можете следовать.</p>
<p>Теперь перейдем непосредственно к controls.cpp</p>
<h1>Основной код<&#47;h1><br />
Итак, нам потребуется несколько переменных:</p>
<pre>&#47;&#47; позиция<br />
glm::vec3 position = glm::vec3( 0, 0, 5 );<br />
&#47;&#47; горизонтальный угол<br />
float horizontalAngle = 3.14f;<br />
&#47;&#47; вертикальный угол<br />
float verticalAngle = 0.0f;<br />
&#47;&#47; поле обзора<br />
float initialFoV = 45.0f;</p>
<p>float speed = 3.0f; &#47;&#47; 3 units &#47; second<br />
float mouseSpeed = 0.005f;<&#47;pre><br />
FoV - это "уровень зума". 80 = очень широкий угол обзора, сильные деформации. Значение от 60 и до 45 является стандартным. 20 - это сильный зум.</p>
<p>В первую очередь мы будем вычислять позицию, горизонтальный и вертикальный углы, а также FoV опираясь на ввод, после чего вычислим Видовую и проекционную матрицы.</p>
<h2>Ориентация<&#47;h2><br />
Чтение позиции мыши - это просто:</p>
<pre>&#47;&#47; Получить позицию мыши<br />
int xpos, ypos;<br />
glfwGetMousePos(&amp;xpos, &amp;ypos);<&#47;pre><br />
однако, нам важно не забыть о перемещении курсора обратно в центр экрана, чтобы он не выходил за границы окна:</p>
<pre>&#47;&#47; Сбросить позицию мыши для следующего кадра<br />
glfwSetMousePos(1024&#47;2, 768&#47;2);<&#47;pre><br />
Обратите внимание, что этот код предполагает, что размеры окна - 1024*768, что не всегда будет являться истиной, поэтому лучшим решением будет использовать glfwGetWindowSize().</p>
<p>Теперь мы можем вычислить наши углы:</p>
<pre>&#47;&#47; Вычисляем углы<br />
horizontalAngle += mouseSpeed * deltaTime * float(1024&#47;2 - xpos );<br />
verticalAngle&nbsp;&nbsp; += mouseSpeed * deltaTime * float( 768&#47;2 - ypos );<&#47;pre><br />
Давайте разберем этот код справа налево:</p>
<ul>
<li>1024&#47;2 &ndash; xpos означает как делеко мышь находится от центра окна. Чем дальше, тем больше будет поворот.<&#47;li>
<li>float(&hellip;) приводит значение в скобках к вещественному типу.<&#47;li>
<li>mouseSpeed - это скорость, с которой будет происходить поворот (чувствительность мыши).<&#47;li>
<li>+= : Если вы не переместили мышь, то 1024&#47;2 - xpos будет равно 0, значит horizontalAngle+=0 не изменит угол.<&#47;li><br />
<&#47;ul><br />
We can now compute a vector that represents, in World Space, the direction in which we&rsquo;re looking</p>
<p>Сейчас нам необходимо вычислить вектор в Мировом пространстве, который будет указывать направление взгляда:</p>
<pre>&#47;&#47; Направление<br />
glm::vec3 direction(<br />
    cos(verticalAngle) * sin(horizontalAngle),<br />
    sin(verticalAngle),<br />
    cos(verticalAngle) * cos(horizontalAngle)<br />
);<&#47;pre><br />
Это стандартное вычисление, но если вы не знаете о синусе и косинусе, то вот небольшая иллюстрация:</p>
<p><img title="Trigonometric circle" alt="" src="http:&#47;&#47;www.numericana.com&#47;answer&#47;trig.gif" width="150" height="150" &#47;></p>
<p>Теперь нам необходимо вычислить вектор "up". То есть вектор, указывает направление вверх для камеры. Обратите внимание, что он не всегда будет равен +Y. К пример, если вы смотрите вниз, то вектор up будет горизонтальным.</p>
<p>В нашем случае, единственное, что остается неизменным - это вектор, который направлен вправо от камеры.</p>
<pre>&#47;&#47; Вектор, указывающий направление вправо от камеры<br />
glm::vec3 right = glm::vec3(<br />
    sin(horizontalAngle - 3.14f&#47;2.0f),<br />
    0,<br />
    cos(horizontalAngle - 3.14f&#47;2.0f)<br />
);<&#47;pre><br />
Итак, у нас есть вектор Вправо и есть направление (вектор Вперед), тогда вектор "вверх" - это вектор, который им перпендикулярен, а чтобы его получить - нужно воспользоваться векторным произведением:</p>
<pre>&#47;&#47; Вектор, указывающий направление вверх относительно камеры<br />
glm::vec3 up = glm::cross( right, direction );<&#47;pre><br />
Чтобы запомнить что делает векторное произведение попробуйте вспомнить Правило правой руки из Урока 3. Первый вектор - это большой палец; Второй вектор - это указательный палец; Результатом будет являться ваш средний палец.</p>
<h2>Позиция<&#47;h2><br />
Далее следует совсем простой код. Кстати, я использую клавиши Вверх&#47;Вниз&#47;Влево&#47;Вправо вместо привычных WASD, потому что у меня AZERTY-клавиатура и соответсвенно AWSD на QWERTY клавиатуре = ZQSD на клавиатуре AZERTY. Также, существуют другие раскладки, о которых не стоит забывать. (Подробнее о раскладках можно узнать <a title="Раскладка клавиатуры" href="http:&#47;&#47;ru.wikipedia.org&#47;wiki&#47;%D0%A0%D0%B0%D1%81%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B0_%D0%BA%D0%BB%D0%B0%D0%B2%D0%B8%D0%B0%D1%82%D1%83%D1%80%D1%8B" target="_blank">тут<&#47;a>).</p>
<pre>&#47;&#47; Движение вперед<br />
if (glfwGetKey( GLFW_KEY_UP ) == GLFW_PRESS){<br />
    position += direction * deltaTime * speed;<br />
}<br />
&#47;&#47; Движение назад<br />
if (glfwGetKey( GLFW_KEY_DOWN ) == GLFW_PRESS){<br />
    position -= direction * deltaTime * speed;<br />
}<br />
&#47;&#47; Стрэйф вправо<br />
if (glfwGetKey( GLFW_KEY_RIGHT ) == GLFW_PRESS){<br />
    position += right * deltaTime * speed;<br />
}<br />
&#47;&#47; Стрэйф влево<br />
if (glfwGetKey( GLFW_KEY_LEFT ) == GLFW_PRESS){<br />
    position -= right * deltaTime * speed;<br />
}<&#47;pre><br />
Единственная непонятная вещь в этом коде - это deltaTime. Если мы просто умножим вектор на скорость, то получим неприятные эффекты:</p>
<ul>
<li>Если у вас быстрый компьютер и приложение работает с частотой кадров 60, то вы будете передвигаться со скоростью 60 юнитов в секунду.<&#47;li>
<li>Если же у вас медленный компьютер и частота кадров = 20, то вы будете передвигаться со скоростью 20 юнитов в секунду.<&#47;li><br />
<&#47;ul><br />
Таким образом тот, кто имеет быстрый компьютер будет двигаться быстрее, поэтому мы вводим переменную, в которую заносим время, прошедшее с последнего кадра. С помощью GLFW оно вычисляется так:</p>
<pre>double currentTime = glfwGetTime();<br />
float deltaTime = float(currentTime - lastTime);<&#47;pre></p>
<h2>Поле обзора<&#47;h2><br />
Для развлечения мы можем также привязать колесико мышки к переменной FoV и менять таким образом Поле обзора, что в итоге даст нас эдакий зум:</p>
<pre>float FoV = initialFoV - 5 * glfwGetMouseWheel();<&#47;pre></p>
<h2>Вычисление матриц<&#47;h2><br />
Мы уже использовали все функции, приведенные ниже в предыдущих уроках, только теперь мы используем другие параметры:</p>
<pre>&#47;&#47; Проекционная матрица: Поле обзора = FoV, отношение сторон 4 к 3, плоскости отсечения 0.1 и 100 юнитов<br />
ProjectionMatrix = glm::perspective(FoV, 4.0f &#47; 3.0f, 0.1f, 100.0f);<br />
&#47;&#47; Матрица камеры<br />
ViewMatrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = glm::lookAt(<br />
    position,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; Позиция камеры<br />
    position+direction, &#47;&#47; Направление камеры<br />
    up&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;&#47; Вектор "Вверх" камеры<br />
);<&#47;pre></p>
<h1>Результат<&#47;h1><br />
<a href="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;moveanim.gif"><img title="moveanim" alt="" src="http:&#47;&#47;www.opengl-tutorial.org&#47;wp-content&#47;uploads&#47;2011&#47;05&#47;moveanim.gif" width="206" height="159" &#47;><&#47;a></p>
<h2>Отсечение задних граней<&#47;h2><br />
Теперь вы можете свободно двигаться вокруг и должны были заметить, что если вы попадаете внутрь куба, то полигоны все равно выводятся. Это кажется нормальным, но в тоже время открывает нам возможность оптимизации, так как в обычных приложениях вы никогда не находитесь внутри куба.</p>
<p>Чтобы не выводить невидимые грани, а соответственно повысить быстродействие нам необходимо проверять где находится камера относительно полигона (спереди или сзади). Хорошая новость в том, что эту проверку очень просто реализовать. GPU должен вычислить нормаль полигона (используя векторное произведение, помните?) и проверяет, как ориентирована нормаль по отношению к камере.</p>
<p>Однако есть один нюанс. Векторное произведение не является коммутативным. Это означает, что порядок, в котором вы умножаете векторы является важным факторов в результате. То есть, если вы перепутаете порядок, то получите неправильную нормаль, а значит не сможете рассчитывать освещение (в дальнейшем) и отсечение невидимых граней будет работать неверно.</p>
<p>Включение режима отсечения полигонов выполняется всего одной командой:</p>
<pre>&#47;&#47; Отсечение тех треугольников, нормаль которых направлена от камеры<br />
glEnable(GL_CULL_FACE);<&#47;pre></p>
<h1>Упражнения<&#47;h1></p>
<ul>
<li>Сделайте так, чтобы вы не могли перемещаться вниз или вверх<&#47;li>
<li>Создайте камеру, которая будет вращаться вокруг заданного объекта. Подсказка:
<ol>
<li>position = ObjectCenter + ( radius * cos(time), height, radius * sin(time) ) );<&#47;li>
<li>привяжите radius, height, time к клавиатуре<&#47;li><br />
<&#47;ol><br />
<&#47;li></p>
<li>Развлекайтесь!<&#47;li><br />
<&#47;ul></p>
